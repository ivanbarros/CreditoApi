# API de Consulta de Cr√©ditos Constitu√≠dos

## üìã Descri√ß√£o

API RESTful desenvolvida em .NET Core 6.0 para gerenciamento e consulta de cr√©ditos constitu√≠dos. O sistema implementa um background service que processa mensagens do Azure Service Bus e armazena os dados em PostgreSQL.

## üöÄ Tecnologias Utilizadas

- **.NET Core 6.0** - Framework principal
- **C#** - Linguagem de programa√ß√£o
- **Entity Framework Core** - ORM para acesso a dados
- **PostgreSQL** - Banco de dados relacional
- **Azure Service Bus** - Mensageria para processamento ass√≠ncrono
- **Docker & Docker Compose** - Containeriza√ß√£o
- **MSTest** - Framework de testes unit√°rios
- **Moq** - Biblioteca para mocking em testes
- **Swagger/OpenAPI** - Documenta√ß√£o da API

## üèóÔ∏è Arquitetura

O projeto segue os seguintes padr√µes de design:

- **Repository Pattern** - Abstra√ß√£o da camada de dados
- **Dependency Injection** - Invers√£o de controle
- **Background Service** - Processamento ass√≠ncrono de mensagens
- **DTO Pattern** - Separa√ß√£o entre modelos de dom√≠nio e transfer√™ncia
- **SOLID Principles** - C√≥digo limpo e manuten√≠vel

### Estrutura do Projeto

```
CreditoAPI/
‚îú‚îÄ‚îÄ Controllers/          # Controladores da API
‚îú‚îÄ‚îÄ Models/              # Entidades do dom√≠nio
‚îú‚îÄ‚îÄ DTOs/                # Objetos de transfer√™ncia de dados
‚îú‚îÄ‚îÄ Data/                # Contexto do Entity Framework
‚îú‚îÄ‚îÄ Repositories/        # Camada de acesso a dados
‚îú‚îÄ‚îÄ Services/            # L√≥gica de neg√≥cio
‚îú‚îÄ‚îÄ BackgroundServices/  # Servi√ßos em background
‚îú‚îÄ‚îÄ Migrations/          # Migra√ß√µes do banco de dados
‚îú‚îÄ‚îÄ Dockerfile           # Configura√ß√£o Docker
‚îî‚îÄ‚îÄ docker-compose.yml   # Orquestra√ß√£o de containers

CreditoAPI.Tests/
‚îú‚îÄ‚îÄ Controllers/         # Testes dos controladores
‚îú‚îÄ‚îÄ Services/           # Testes dos servi√ßos
‚îî‚îÄ‚îÄ Repositories/       # Testes dos reposit√≥rios
```

## üìä Modelagem de Dados

```sql
CREATE TABLE credito
(
    id                BIGINT GENERATED BY DEFAULT AS IDENTITY,
    numero_credito    VARCHAR(50)    NOT NULL,
    numero_nfse       VARCHAR(50)    NOT NULL,
    data_constituicao DATE           NOT NULL,
    valor_issqn       DECIMAL(15, 2) NOT NULL,
    tipo_credito      VARCHAR(50)    NOT NULL,
    simples_nacional  BOOLEAN        NOT NULL,
    aliquota          DECIMAL(5, 2)  NOT NULL,
    valor_faturado    DECIMAL(15, 2) NOT NULL,
    valor_deducao     DECIMAL(15, 2) NOT NULL,
    base_calculo      DECIMAL(15, 2) NOT NULL
);
```

## üîå Endpoints da API

### 1. Integrar Cr√©ditos Constitu√≠dos

**POST** `/api/creditos/integrar-credito-constituido`

Envia cr√©ditos para o t√≥pico do Service Bus para processamento ass√≠ncrono.

**Request Body:**
```json
[
  {
    "numeroCredito": "123456",
    "numeroNfse": "7891011",
    "dataConstituicao": "2024-02-25",
    "valorIssqn": 1500.75,
    "tipoCredito": "ISSQN",
    "simplesNacional": "Sim",
    "aliquota": 5.0,
    "valorFaturado": 30000.00,
    "valorDeducao": 5000.00,
    "baseCalculo": 25000.00
  }
]
```

**Response:** `202 Accepted`
```json
{
  "success": true
}
```

### 2. Buscar Cr√©ditos por NFS-e

**GET** `/api/creditos/{numeroNfse}`

Retorna todos os cr√©ditos associados a uma NFS-e.

**Response:** `200 OK`
```json
[
  {
    "numeroCredito": "123456",
    "numeroNfse": "7891011",
    "dataConstituicao": "2024-02-25",
    "valorIssqn": 1500.75,
    "tipoCredito": "ISSQN",
    "simplesNacional": "Sim",
    "aliquota": 5.0,
    "valorFaturado": 30000.00,
    "valorDeducao": 5000.00,
    "baseCalculo": 25000.00
  }
]
```

### 3. Buscar Cr√©dito por N√∫mero

**GET** `/api/creditos/credito/{numeroCredito}`

Retorna os detalhes de um cr√©dito espec√≠fico.

**Response:** `200 OK`
```json
{
  "numeroCredito": "123456",
  "numeroNfse": "7891011",
  "dataConstituicao": "2024-02-25",
  "valorIssqn": 1500.75,
  "tipoCredito": "ISSQN",
  "simplesNacional": "Sim",
  "aliquota": 5.0,
  "valorFaturado": 30000.00,
  "valorDeducao": 5000.00,
  "baseCalculo": 25000.00
}
```

### 4. Health Check - Self

**GET** `/api/self`

Verifica se o servi√ßo est√° ativo.

**Response:** `200 OK`
```json
{
  "status": "healthy",
  "service": "CreditoAPI",
  "timestamp": "2024-02-25T10:30:00Z",
  "version": "1.0.0"
}
```

### 5. Health Check - Ready

**GET** `/api/ready`

Verifica se o servi√ßo est√° pronto (banco de dados conectado).

**Response:** `200 OK` ou `503 Service Unavailable`
```json
{
  "status": "Healthy",
  "checks": [
    {
      "name": "database",
      "status": "Healthy",
      "description": null,
      "duration": 45.2
    }
  ],
  "totalDuration": 45.2,
  "timestamp": "2024-02-25T10:30:00Z"
}
```

## üîß Configura√ß√£o e Instala√ß√£o

### Pr√©-requisitos

- [.NET 6.0 SDK](https://dotnet.microsoft.com/download/dotnet/6.0)
- [Docker Desktop](https://www.docker.com/products/docker-desktop)
- [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) (opcional)

### Configura√ß√£o do Azure Service Bus

1. Crie um namespace do Service Bus no Azure
2. Crie um t√≥pico chamado `integrar-credito-constituido-entry`
3. Crie uma assinatura para o t√≥pico
4. Obtenha a connection string do Service Bus

### Vari√°veis de Ambiente

Edite o arquivo `appsettings.json` ou configure as vari√°veis de ambiente:

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=creditodb;Username=postgres;Password=postgres"
  },
  "ServiceBus": {
    "ConnectionString": "Endpoint=sb://your-namespace.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=your-key",
    "TopicName": "integrar-credito-constituido-entry",
    "SubscriptionName": "credito-processor"
  },
  "BackgroundService": {
    "ProcessingIntervalMs": 500
  }
}
```

## üê≥ Executando com Docker

### Op√ß√£o 1: Docker Compose (Recomendado)

```bash
# Clone o reposit√≥rio
git clone <repository-url>
cd CreditoAPI

# Inicie os containers
docker-compose up -d

# Verifique os logs
docker-compose logs -f api

# Pare os containers
docker-compose down

# Pare e remova os volumes (dados do banco)
docker-compose down -v
```

A API estar√° dispon√≠vel em: `http://localhost:5000`

Swagger UI: `http://localhost:5000/swagger`

### Op√ß√£o 2: Docker Manual

```bash
# Build da imagem
docker build -t creditoapi .

# Execute o PostgreSQL
docker run -d \
  --name postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=creditodb \
  -p 5432:5432 \
  postgres:14-alpine

# Execute a API
docker run -d \
  --name creditoapi \
  -p 5000:80 \
  -e ConnectionStrings__DefaultConnection="Host=postgres;Port=5432;Database=creditodb;Username=postgres;Password=postgres" \
  --link postgres:postgres \
  creditoapi
```

## üíª Executando Localmente (Sem Docker)

### 1. Instalar Depend√™ncias

```bash
cd CreditoAPI
dotnet restore
```

### 2. Configurar Banco de Dados

Certifique-se de que o PostgreSQL est√° rodando e atualize a connection string em `appsettings.json`.

### 3. Aplicar Migra√ß√µes

```bash
dotnet ef database update
```

### 4. Executar a API

```bash
dotnet run
```

A API estar√° dispon√≠vel em: `https://localhost:7000` ou `http://localhost:5000`

## üß™ Executando os Testes

### Todos os Testes

```bash
cd CreditoAPI.Tests
dotnet test
```

### Com Cobertura de C√≥digo

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
```

### Testes Espec√≠ficos

```bash
# Testes de servi√ßos
dotnet test --filter "FullyQualifiedName~CreditoAPI.Tests.Services"

# Testes de reposit√≥rios
dotnet test --filter "FullyQualifiedName~CreditoAPI.Tests.Repositories"

# Testes de controladores
dotnet test --filter "FullyQualifiedName~CreditoAPI.Tests.Controllers"
```

## üîÑ Fluxo de Funcionamento

1. **Integra√ß√£o de Cr√©ditos:**
   - Cliente envia lista de cr√©ditos via POST `/api/creditos/integrar-credito-constituido`
   - API publica cada cr√©dito como mensagem individual no Azure Service Bus
   - Retorna status 202 (Accepted) imediatamente

2. **Processamento em Background:**
   - Background service verifica o Service Bus a cada 500ms
   - Recebe mensagens do t√≥pico
   - Valida se o cr√©dito j√° existe no banco (evita duplicatas)
   - Insere cr√©ditos novos no PostgreSQL de forma individual (n√£o bulk)

3. **Consulta de Cr√©ditos:**
   - Cliente pode consultar cr√©ditos por NFS-e ou n√∫mero do cr√©dito
   - API retorna dados diretamente do PostgreSQL

## üìù Padr√µes de Projeto Implementados

### 1. Repository Pattern
Abstra√ß√£o da camada de dados, facilitando testes e manuten√ß√£o.

```csharp
public interface ICreditoRepository
{
    Task<Credito?> GetByNumeroCreditoAsync(string numeroCredito);
    Task<List<Credito>> GetByNumeroNfseAsync(string numeroNfse);
    Task<Credito> AddAsync(Credito credito);
    Task<bool> ExistsAsync(string numeroCredito);
}
```

### 2. Dependency Injection
Todas as depend√™ncias s√£o injetadas via construtor.

```csharp
public class CreditoService : ICreditoService
{
    private readonly ICreditoRepository _repository;
    private readonly IServiceBusService _serviceBusService;
    private readonly ILogger<CreditoService> _logger;

    public CreditoService(
        ICreditoRepository repository,
        IServiceBusService serviceBusService,
        ILogger<CreditoService> logger)
    {
        _repository = repository;
        _serviceBusService = serviceBusService;
        _logger = logger;
    }
}
```

### 3. Background Service Pattern
Processamento ass√≠ncrono de mensagens.

```csharp
public class CreditoProcessorService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            // Processa mensagens a cada 500ms
            await Task.Delay(_processingIntervalMs, stoppingToken);
        }
    }
}
```

### 4. DTO Pattern
Separa√ß√£o entre modelos de dom√≠nio e transfer√™ncia de dados.

## üîí Boas Pr√°ticas Implementadas

- ‚úÖ **SOLID Principles**
- ‚úÖ **Clean Code**
- ‚úÖ **Async/Await** para opera√ß√µes I/O
- ‚úÖ **Logging** estruturado
- ‚úÖ **Exception Handling** adequado
- ‚úÖ **Valida√ß√£o de dados**
- ‚úÖ **Health Checks**
- ‚úÖ **Containeriza√ß√£o**
- ‚úÖ **Testes Unit√°rios**
- ‚úÖ **Documenta√ß√£o Swagger**

## üìà Melhorias Futuras

- [ ] Implementar autentica√ß√£o e autoriza√ß√£o (JWT)
- [ ] Adicionar rate limiting
- [ ] Implementar cache (Redis)
- [ ] Adicionar testes de integra√ß√£o
- [ ] Implementar circuit breaker para Service Bus
- [ ] Adicionar m√©tricas e observabilidade (Prometheus/Grafana)
- [ ] Implementar versionamento da API
- [ ] Adicionar pagina√ß√£o nos endpoints de listagem

## ü§ù Contribuindo

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudan√ßas (`git commit -m 'Add some AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request

## üìÑ Licen√ßa

Este projeto foi desenvolvido como parte de um desafio t√©cnico.

## üë• Autor

Desenvolvido como parte do desafio t√©cnico de desenvolvimento .NET Core.

## üìû Suporte

Para d√∫vidas ou problemas, abra uma issue no reposit√≥rio.

---

**Nota:** Este projeto atende a todos os requisitos especificados no desafio t√©cnico, incluindo:
- ‚úÖ .NET Core 6.0+
- ‚úÖ Entity Framework Core
- ‚úÖ PostgreSQL
- ‚úÖ Azure Service Bus
- ‚úÖ Docker & Docker Compose
- ‚úÖ Background Service (processamento a cada 500ms)
- ‚úÖ Inser√ß√£o individual (n√£o bulk)
- ‚úÖ Health checks (/self e /ready)
- ‚úÖ Testes unit√°rios (MSTest)
- ‚úÖ Padr√µes de projeto (Repository, Dependency Injection, etc.)
- ‚úÖ C√≥digo limpo e bem documentado
